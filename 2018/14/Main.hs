{-# LANGUAGE DeriveFunctor #-}

import           Data.List                   (unfoldr)
import qualified Data.Tree                   as Tree
import qualified Data.Vector.Generic.Mutable as GM
import qualified Data.Vector.Unboxed.Mutable as U
import           Data.Word
import           System.Environment
import           System.Exit

data Zipper a = Zipper
  { idx    :: Int
  , zlen   :: Int
  , lefts  :: [a]
  , focus  :: a
  , rights :: [a]
  } deriving (Show, Eq, Functor)

main :: IO ()
main = do
  args <- getArgs
  case args of
    ["pt1"] -> pt1
    ["pt2"] -> pt2
    _       -> die "bad arguments. Expected pt1 or pt2"

pt1 :: IO ()
pt1 = do
  mapM_ (putStr . show) (take 10 $ drop 74501 $ theSequence)
  putStrLn ""

pt2 :: IO ()
pt2 = pt2StateMachine [0,7,4,5,0,1]
-- the pure implementation (print (indexOf [0,7,4,5,0,1] theSequence))
-- is just too slow

initScoreBoard :: Num n => Zipper n
initScoreBoard = fromList [3,7]

-- more efficient state machine, based on mutable vectors.
-- Uglier more convoluted code, but orders of magnitude quicker
pt2StateMachine :: [Word8] -> IO ()
pt2StateMachine needle = do
  v <- GM.replicate 1024 0 -- start with a big array, and grow by doubling it
  U.write v 0 3
  U.write v 1 7
  let positions = (0,1)
  step v [3,7] positions 2 0
 where
   nsize = length needle
   -- step has two phases: either we have enough, or we need more
   step :: U.IOVector Word8 -> [Word8] -> (Int,Int) -> Int -> Int -> IO ()
   -- inlined indexOf
   step v currHay pos len i | length currHay >= nsize = do
     if take nsize currHay == needle
        then print i
        else step v (tail currHay) pos len (i + 1)
   -- find more values and feed them to the next stage
   step v currHay (ia,ib) len i = do
     vala <- GM.read v ia
     valb <- GM.read v ib
     let newRecipes = digits (vala + valb)
         len' = len + length newRecipes
         ia' = (ia + (fromIntegral vala) + 1) `mod` len'
         ib' = (ib + (fromIntegral valb) + 1) `mod` len'
         vlen = GM.length v
     v' <- if (len' > vlen)
              then U.grow v vlen
              else pure v
     mapM_ (\(i, n) -> U.write v' i n) (zip [len ..] newRecipes)
     step v' (currHay ++ newRecipes) (ia', ib') len' i

-- infinite stream of words generated by this sequence
theSequence :: [Word8]
theSequence = [3,7] ++ (concat $ unfoldr go ((0,1), initScoreBoard))
  where
    go (positions, z) = let (ps', z') = run positions z
                         in Just (rights z', (ps', z'))

indexOf :: Eq a => [a] -> [a] -> Maybe Int
indexOf [] = \_ -> error "Cannot search for empty sequence"
indexOf (n:eedle) = go 0
  where
    suff = take (length eedle)
    go i [] = Nothing
    go i (hay:stack)
      | n == hay && eedle == suff stack = Just i
      | otherwise                       = go (i + 1) stack

-- pure implementation, using a zipper for efficient appends
-- The seeks back and forth to the vals ruin it though.
run :: (Integral a, Num a, Show a, Read a)
    => (Int,Int) -> Zipper a -> ((Int, Int), Zipper a)
run (idxa, idxb) z
  = let vala = focus $ shiftTo idxa z
        valb = focus $ shiftTo idxb z
        newRecipes = digits (vala + valb)
        z' = foldr insertR (shiftToEnd z) newRecipes
        idxa' = (idxa + (fromIntegral vala) + 1) `mod` zlen z'
        idxb' = (idxb + (fromIntegral valb) + 1) `mod` zlen z'
     in ((idxa', idxb'), z')

digits :: (Show a, Read b, Num b) => a -> [b]
digits = fmap (read . return) . show

left :: Zipper a -> Zipper a
left (Zipper i n [] a [])         = Zipper i n [] a []
left (Zipper i n [] a rs)         = left (Zipper i n (reverse rs) a [])
left (Zipper i n (new:ls) old rs) = Zipper (pred i) n ls new (old:rs)

right :: Zipper a -> Zipper a
right (Zipper i _ [] a [])         = Zipper i 1 [] a []
right (Zipper i n ls a [])         = right (Zipper i n [] a (reverse ls))
right (Zipper i n ls old (new:rs)) = Zipper (succ i) n (old:ls) new rs

insertR :: a -> Zipper a -> Zipper a
insertR elem (Zipper i n ls a rs) = Zipper i (n + 1) ls a (elem:rs)

shiftToEnd :: Zipper a -> Zipper a
shiftToEnd z = shiftTo (zlen z - 1) z

shift :: Int -> Zipper a -> Zipper a
shift 0 z = z
shift n z
  | n < 0     = shift (succ n) (left z)
  | otherwise = shift (pred n) (right z)

shiftTo :: Int -> Zipper a -> Zipper a
shiftTo i z = shift (i - idx z) z

toList :: Zipper a -> [a]
toList z = focus z : rights z ++ reverse (lefts z)

fromList :: [a] -> Zipper a
fromList []     = error "cannot build zipper for empty list"
fromList (a:as) = Zipper 0 (1 + length as) [] a as

