{-# LANGUAGE DeriveFunctor #-}

import           Data.Function
import           Data.List                   (unfoldr)
import qualified Data.Vector.Generic.Mutable as GM
import qualified Data.Vector.Unboxed.Mutable as U
import           Data.Word
import           System.Environment
import           System.Exit

import           Elves.Zipper                (Zipper)
import qualified Elves.Zipper                as Z

main :: IO ()
main = do
  args <- getArgs
  case args of
    ["pt1"] -> pt1
    ["pt2"] -> pt2
    _       -> die "bad arguments. Expected pt1 or pt2"

pt1 :: IO ()
pt1 = do
  mapM_ (putStr . show) (take 10 $ drop 74501 $ theSequence)
  putStrLn ""

pt2 :: IO ()
pt2 = pt2StateMachine [0,7,4,5,0,1]
-- the pure implementation (print (indexOf [0,7,4,5,0,1] theSequence))
-- is just too slow

initScoreBoard :: Num n => Zipper n
initScoreBoard = Z.singleton 3 & Z.insertR 7

-- more efficient state machine, based on mutable vectors.
-- Uglier more convoluted code, but orders of magnitude quicker
pt2StateMachine :: [Word8] -> IO ()
pt2StateMachine needle = do
  v <- GM.replicate 1024 0 -- start with a big array, and grow by doubling it
  U.write v 0 3
  U.write v 1 7
  let positions = (0,1)
  step v [3,7] positions 2 0
 where
   nsize = length needle
   -- step has two phases: either we have enough, or we need more
   step :: U.IOVector Word8 -> [Word8] -> (Int,Int) -> Int -> Int -> IO ()
   -- inlined indexOf
   step v currHay pos len i | length currHay >= nsize = do
     if take nsize currHay == needle
        then print i
        else step v (tail currHay) pos len (i + 1)
   -- find more values and feed them to the next stage
   step v currHay (ia,ib) len i = do
     vala <- GM.read v ia
     valb <- GM.read v ib
     let newRecipes = digits (vala + valb)
         len' = len + length newRecipes
         ia' = (ia + (fromIntegral vala) + 1) `mod` len'
         ib' = (ib + (fromIntegral valb) + 1) `mod` len'
         vlen = GM.length v
     v' <- if (len' > vlen)
              then U.grow v vlen
              else pure v
     mapM_ (\(i, n) -> U.write v' i n) (zip [len ..] newRecipes)
     step v' (currHay ++ newRecipes) (ia', ib') len' i

-- infinite stream of words generated by this sequence
theSequence :: [Word8]
theSequence = [3,7] ++ (concat $ unfoldr go ((0,1), initScoreBoard))
  where
    go (positions, z) = let (ps', z') = run positions z
                         in Just (Z.rights z', (ps', z'))

indexOf :: Eq a => [a] -> [a] -> Maybe Int
indexOf [] = \_ -> error "Cannot search for empty sequence"
indexOf (n:eedle) = go 0
  where
    suff = take (length eedle)
    go i [] = Nothing
    go i (hay:stack)
      | n == hay && eedle == suff stack = Just i
      | otherwise                       = go (i + 1) stack

-- pure implementation, using a zipper for efficient appends
-- The seeks back and forth to the vals ruin it though.
run :: (Integral a, Num a, Show a, Read a)
    => (Int,Int) -> Zipper a -> ((Int, Int), Zipper a)
run (idxa, idxb) z
  = let vala = Z.focus $ Z.shiftTo idxa z
        valb = Z.focus $ Z.shiftTo idxb z
        newRecipes = digits (vala + valb)
        z' = foldr Z.insertR (Z.shiftToEnd z) newRecipes
        idxa' = (idxa + (fromIntegral vala) + 1) `mod` Z.zlen z'
        idxb' = (idxb + (fromIntegral valb) + 1) `mod` Z.zlen z'
     in ((idxa', idxb'), z')

digits :: (Show a, Read b, Num b) => a -> [b]
digits = fmap (read . return) . show
